---
title: "STAT545 Homework 4: Data wrangling with data aggregation and data reshaping"
author: "Rebecca Asiimwe"
date: '2018-10-06'
output:
  github_document:
    toc: yes
---
# STAT545 Homework 4: Data wrangling with data aggregation and data reshaping

Data analysis tasks involve 3 main components, `(1) Data Manipulation`, `(2) Data Cleaning` and `(3) Data Visualization`. In my previous assignments, I showed the [application of dply for data exploration and manipulation, followed by visualisation of the data using ggplot2.](https://github.com/STAT545-UBC-students/hw03-rasiimwe/blob/master/hw03-rasiimwe.md). It is estimated that 80% of data analysis tasks are inclined to data manipulation and cleaning. This is attribtued to the growth in data sources that need preparation to efficiently handle this data 

## The dplyr library as a major component of the data analysis ecosystem. 

[<img align ="center" src="https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/dplyr.png" width="500" height="300"/>](https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/dplyr.png)

Herein, I present **the application of the dplyr package in supporting data manipulation operations** for data anlysis. Here we shall focus on manipulating data using functions such as `gather()`, `spread()`, `mutating joins`, `filtering joins`, `set operations` and `biding` datasets. 

### Loading required packages

First, I will load all packages required for this assignment

```{r}
suppressPackageStartupMessages(library(tidyverse)) 
suppressPackageStartupMessages(library(gapminder))
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(knitr))
suppressPackageStartupMessages(library(cowplot))
```

## Qn 1. Data Reshaping Prompt
Overview: Problem - You have data in one “shape” but you wish it were in another. Usually this is because the alternative shape is superior for presenting a table, making a figure, or doing aggregation and statistical analysis. 
          Solution: Reshape your data. For simple reshaping, gather() and spread() from tidyr will suffice. 

### Activity #2
> Make a tibble with one row per year and columns for life expectancy for two or more countries.
> Use knitr::kable() to make this table look pretty in your rendered homework.
> Take advantage of this new data shape to scatterplot life expectancy for one country against that of another.

### Make a tibble with one row per year and columns for life expectancy for two or more countries.

```{r}
countries <- c("Cambodia", "Bulgaria","Malawi", "Kuwait") #selecting countries for inclusion in my tibble

life_expectancy <- gapminder %>%
  filter(country %in% countries) %>% #filtering the gapminder dataset for the four countries in my vector countries
  select(country, year, lifeExp) %>% #selecting variable for inclusion in my tibble life_expectancy
  group_by(year) #choosing to group by year
  
kable(life_expectancy) #applying the kable function to render a neat/ nicely presented table
```

As we can see, the tibble is in long format but what we would like to have is a tibble with one row per year and columns for life expectancy for two or more countries. To do this, I apply the spread function as shown below.

```{r}
life_expectancy <- life_expectancy %>% 
  spread(key = country, value = lifeExp) #applying the spread function from dplyr to spread selected countries based on lifeExp (value) across the tibble columns
```

### Use knitr::kable() to make this table look pretty in your rendered homework.

Below I show a more tidy and usable tibble using the kable() function

```{r}

kable(life_expectancy)

```

As we can see above, our initial table that was in long format is now in wide and more tidy form to support the building of the required scatter plot for the subsequent section. 

### Take advantage of this new data shape to scatterplot life expectancy for one country against that of another.

```{r}
 CambodiaVsBulgaria<- life_expectancy %>%
  ggplot(aes(Cambodia, Bulgaria)) +
  geom_point() + ggtitle("Life Expectancy") + theme_gray()+
  labs(title="Life Expectancy CambodiaVsBulgaria",x="life_expectancy of Cambodia", y="life_expectancy of Bulgaria")

 KuwaitVsMalawi<- life_expectancy %>%
  ggplot(aes(Kuwait, Malawi)) +
  geom_point() + ggtitle("Life Expectancy") + theme_gray()+
labs(title="Life Expectancy KuwaitVsMalawi ",x="life_expectancy of Kuwait", y="life_expectancy of Malawi")

plot_grid(CambodiaVsBulgaria,  KuwaitVsMalawi, nrow=1, ncol = 2)
```

Above, we see scatter plots that have been build from the new transformed tibble (life_expectancy). The shapes that our data takes on may or may not support the kinds of analyses we need. In this case, we wouldnt have been able to create these plots had the data stayed in the long format which further goes to show for the need of data reshaping before futher analysis is done. It also helps to know which data formats support which type of analysis.

## Qn 2. Join Prompt 
Overview: Problem - You have two data sources and you need info from both in one new data object.
          Solution: Perform a join, which borrows terminology from the database world, specifically SQL.

### Activity #2 :Create your own cheatsheet 
> Create your own cheatsheet patterned after [Jenny’s](http://stat545.com/bit001_dplyr-cheatsheet.html) but focused on something you care about more than comics! Inspirational examples:
  + Pets I have owned + breed + friendly vs. unfriendly + ??. Join to a table of pet breed, including variables for furry vs not furry, mammal true or false, etc.
  + Movies and studios….
  + Athletes and teams….
You will likely need to iterate between your data prep and your joining to make your explorations comprehensive and interesting. For example, you will want a specific amount (or lack) of overlap between the two data.frames, in order to demonstrate all the different joins. You will want both the data frames to be as small as possible, while still retaining the expository value.

### Introduction to dplyr's join functions

[<img align ="center" src="https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/join-venn.png" width="800" height="250"/>](https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/join-venn.png)

Before we dig deeper into the various join functions, I will create the tibbles required to explore that application of these functions

### Creating tibble 1 
The idea and data used is derived from the wikipedia page of [preseidents of the United States](https://en.wikipedia.org/wiki/List_of_Presidents_of_the_United_States)

```{r}
presidents <- tibble(
  name = c("Donald Trump", "Barack Obama", "George W. Bush", "Bill Clinton","George H. W. Bush", "Ronald Reagan", "Jimmy Carter","Gerald Ford", "Richard Nixon", "Rebecca Asiimwe"),
  previous_office = c("Chairman of The Trump Organization", "U.S. Senator from Illinois", "Governor of Texas", "Governor of Arkansas","Vice President of the United States", "Governor of California", "Governor of Georgia","Vice President of the United States", "Vice President of the United States", "Senior Bioinformatician BCCRC"),
  party=c("Republican", "Democratic", "Republican", "Democratic","Republican", "Republican", "Democratic","Republican", "Republican","Independent"),
  vice = c("Mike Pence", "Joe Biden", "Dick Cheney", "Al Gore","Dan Quayle", "George H. W. Bush", "Walter Mondale","Nelson Rockefeller", "Gerald Ford","Unknown"),
  in_office=c(2007, 2009, 2001, 1993,1989, 1981, 1977,1974, 1969,1900),
  out_office=c(2021, 2017, 2009, 2001,1993, 1989, 1981,1977, 1974,1969)
)

kable(presidents)
```

The first tibble I have created above is that of presidents of the United states from 1969 to date. For the fun of it, I also inclued an artifuctual president to help point out salient dimensions when working with table joins. 

### Creating tibble 2
```{r}
parties <- tibble(
  party=c("Republican", "Democratic", "Other"),
  lead=c("Ronna McDaniel", "Tom Perez", "Nameless")
)

kable(parties) 
```

The second tibble above shows the unique political parites in the United States and the respective party leads.

## Mutating joins:

**Joining tibbles using mutating functions:**

  1. `left_join`
  2. `right_join`
  3. `inner_join` 
  4. `full_join`

** By default all joins will be by party `left_join(presidents, parties, by="party")`**

### Left Join

[<img align ="center" src="https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/left-join.gif" width="300" height="300"/>](https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/left-join.gif)

**Basic syntax:** `left_join(x, y)`

**Join Function:** 

left_join(x, y): keep all x, drop unmatched y:-  Return all rows from ‘x’, and all columns from ‘x’ and ‘y’. Rows in ‘x’ with no match in ‘y’ will have ‘NA’ values in the new columns. If there are multiple matches between ‘x’ and ‘y’, all combinations of the matches are returned.

#### left_join on presidents & parties

```{r}
left_join(presidents, parties) %>% 
  kable()
```

In the table above table, we see the effect of a left_join on the `presidents` and `parties` tibbles - (presidents, parties). We see that in the output we have maintained the `presidents` tibble concartenated with an additional variable `lead` from the `parties` tibble. In this case, the party lead from the parties tibble is being matched with each row in the presidents table based on the party variable. The parties are unique and since president Rebecca Asiimwe's party does not appear in the `parties` tibble, the lead is replaced with NA in the output table above. Let's try a left_join on parties and presidents.

##### left_join on parties & presidents

```{r}
left_join(parties, presidents) %>% 
  kable()
```

What happened here!! .... the output table looks different and yet more interesting. When we look closely we see that Rebecca Asiimwe has been droped in this join operation in which we are doing a left join of presidents on parties and joining by the party variable from the parties table. The drop of this president is mainly because, her party does not appear in the parties table. In a nutshell what is going on here is that the left join on (parties, presidents) has maintained all variables from the parties tibble plus matching rows from the presidents table. 


### Right Join

[<img align ="center" src="https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/right-join.gif" width="300" height="300"/>](https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/right-join.gif)

**Basic syntax:** `right_join(x, y)`

**Function**: keep all y, drop unmatched x:- return all rows from ‘y’, and all columns from ‘x’ and y. Rows in ‘y’ with no match in ‘x’ will have ‘NA’ values in the new columns. If there are multiple matches between ‘x’ and ‘y’, all combinations of the matches are returned

#### right_join on presidents & parties

```{r}
right_join(presidents, parties) %>% 
  kable()
```

The right join on (presidents, parties) maintains all tupples/rows from the presidents tibble for which there are matching rows in the parties table. As we can see, this includes all the rows from the parties and only those from the presidents tibble that match. President Rebecca Asiimwe was droped by the right join since their party does not match any of those in the parties tibble.

##### right join on parties & presidents
```{r}
right_join(parties, presidents) %>% 
  kable()
```

Here we see that the right_join on (parties, presidents) maintains all rows from the parties tibble and concartenates them with all rows from the presidents tibble. Unlike the left joins on (parties, presidents) that droped non matching rows as seen above, here non matching rows are included as well with NAs used for cases of missing values.

### Inner Join

[<img align ="center" src="https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/inner-join.gif" width="300" height="300"/>](https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/inner-join.gif)

**Basic syntax:** `inner_join(x, y)`

**Join Function:** 

inner_join(x, y): : keep only matching:- Return all rows from x where there are matching values in y, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned. 

#### inner_join on presidents & parties

```{r}
inner_join(presidents, parties) %>% 
  kable()
```

The output of the inner join as see above results in the inclusion of all the rows of the parties tibble to match rows in presidents tibble - matching is done by party. As we can see, president Rebecca Asiimwe was droped by the inner join because the party to which she belongs (Independent) does not match any of those in the parties tibble/ does not exist in the parties table. 

##### inner_join on parties & presidents 
```{r}
inner_join(parties, presidents) %>% 
  kable()
```

An inner join on parties and presidents on variable party results in every party in the parties table being matched with every president in the presidents tibble. We can also see that every party appears multiple times in the above output table and appearing once for each matching row. We can still see that president Rebecca Asiimwe was dropped from the result of the join because her party does not appear in the parties table and therefore wouldn't match any row in the presidents table.


### Full Join

[<img align ="center" src="https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/full-join.gif" width="300" height="300"/>](https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/full-join.gif)

**Basic syntax:** `full_join(x, y): keep everything`

**Join Function:** 

full_join(x, y): Return all rows and all columns from both x and y. Where there are not matching values, returns NA for the one missing. This is a mutating join.

#### full_join on presidents & parties

```{r}
full_join(presidents, parties) %>% 
  kable()
```

The full join functions just like taking the union of two sets. From the output table of this join we get all variables of presidents plus all variables from the lead table, however, we should note that the unique variable on which the join is being made (where the two table intersect=party) is not duplicated. With a full join, all rows without matching values from either table carry NAs in the variables found only in the other table.

```{r}
full_join(parties, presidents) %>% 
  kable()
```

In  the above table we have a similar output to that of a full join on presidents and parties except for the fact that joining is done on the parties table, (inner vs outer / left vs right table in join). And we can also see that variables from the presidents table get appended to the party table, however, we see the contrary in the full join on presidents and parties since we are joining the parties tibble to the presidents tibble by party. 

## Filtering joins:

**Joining tibbles using filtering functions:** 

  1. `semi_join`
  2. `anti_join`

### Semi Join

[<img align ="center" src="https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/semi-join.gif" width="300" height="300"/>](https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/semi-join.gif)

**Basic syntax:** `semi_join(x, y)`

**Join Function:** 

semi_join(x, y):return rows from x where there are matching values in y:- Return all rows from x where there are matching values in y, keeping just columns from x. A semi join differs from an inner join because an inner join will return one row of x for each matching row of y, where a semi join will never duplicate rows of x. This is a filtering join.


#### semi_join on presidents & parties

```{r}
semi_join(presidents, parties) %>% 
  kable()
```

Here we get a similar result as those got from the inner_join(presidents, parties) however, we only maintain variables in the presidents tibble.

##### semi_join on parties & presidents
```{r}
semi_join(parties, presidents) %>% 
  kable()
```

From the above output of the semi join, we can see that a semi join of presidents on parties by party provides results are are similart to our tibble parties. All observations in the parties table appear in the presidents table. We also see here that the party named "Other" for which there are no matching rows in the presidents tibble has been dropped by the semi join. 


### Anti Join

[<img align ="center" src="https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/anti-join.gif" width="300" height="300"/>](https://github.com/STAT545-UBC-students/hw04-rasiimwe/blob/master/plugins/anti-join.gif)

anti_join(x, y): Return all rows from x where there are not matching values in y, keeping just columns from x. This is a filtering join.

#### anti_join on presidents & parties

```{r}
anti_join(presidents, parties) %>% 
  kable()
```

From the above output table, we can see that the operation of the anti join filters and returns rows in the presidents table that do not match values in the parties tibble. Here president Rebecca Asiimwe whoes party does not appear in the parties table has been returned as the output from the anti join. 

#### anti_join on parties & presidents 
```{r}
anti_join(parties, presidents) %>% 
  kable()
```

The anti_join(parties, presidents) now works in the opposite direction to the anti_join(presidents, parties) by returning rows in the parties table that do not match values in the presidents tibble. Here the party called "Other" that does not appear in the presidents table has been returned as the result of the anti_join(parties, presidents)

## Set Operations:
In this section, I explore set operations and how we can apply them in out data manipulation tasks. To allow for the exploration of set operations, I will create two more datasets of professors at UBC and in the Bioinformatics and Statistics Departments.

```{r}
Bioinformatics_profs <- tibble(
  name=c("Sara Mostafavi", "Sohrab Shah", "Charmaine Dean", "Steve Jones", "Jinko Graham", "Brad McNeney","Fiona Brinkman")
)
Bioinformatics_profs %>% 
  kable

STAT_profs <- tibble(
  name=c("Vincenzo Coia","Jennifer Bryan", "Sara Mostafavi", "Charmaine Dean","Jinko Graham","Brad McNeney", "Suborna Ahmed")
)
STAT_profs %>% 
  kable
```


**Functions used for set operations on two tibbles:**

  1. `intersect()`
  2. `union()`
  3. `setdiff()`

### Intersect 
**Funcition:** The intersect function returns rows that appear in both x and y

```{r}
intersect(Bioinformatics_profs, STAT_profs) %>% 
  kable
```

The purpose of the intersect function is to return rows that appear in both tibbles. In the above output table we see professors that are both in the Statistics and Bioinformatics programs. If there were no observations that appear in both tables, R would throw back the error message: "`Error in intersect_data_frame(x, y) : not compatible: - Cols in y but not x: `lead`. - Cols in x but not y: `out_office`, `vice`, `in_office`, `previous_office`, `name`.`"

### setdiff(Bioinformatics_profs, STAT_profs) 
**Funcition:** The intersect function returns rows that appear in x but not y. 

```{r}
setdiff(Bioinformatics_profs, STAT_profs) %>% 
  kable
```

##### setdiff

```{r}
setdiff(STAT_profs, Bioinformatics_profs) %>% 
  kable
```

### Union 
**Funcition:** The union function returns rows that appear in either or both x and y

```{r}
union(STAT_profs, Bioinformatics_profs) %>% 
  kable
```


## Biding datasets:
Many a times we have the need to concartenate tibbles/ dataframes. To achive this, we apply the bind_rows and bind_cols functions as will be explored below.

  1. `bind_rows()` 
  2. `bind_cols()`

```{r}
bind_rows(STAT_profs, Bioinformatics_profs) %>% 
  kable
```

```{r}
bind_cols(STAT_profs, Bioinformatics_profs) %>% 
  kable

```


## Activity #3

> This is really an optional add-on to either of the previous activities.
Explore the base R function merge(), which also does joins. Compare and contrast with dplyr joins.
Explore the base R function match(), which is related to joins and merges, but is really more of a “table lookup”. Compare and contrast with a true join/merge.

```{r}
merge(STAT_profs, Bioinformatics_profs) %>% 
  kable
#merge(presidents, parties) %>% 
#  kable
```

By default the data frames are merged on the columns with names they both have, but separate specifications of the columns can be given by by.x and by.y. The rows in the two data frames that match on the specified columns are extracted, and joined together. If there is more than one match, all possible matches contribute one row each. For the precise meaning of ‘match’, see match.

```{r}
match(STAT_profs, Bioinformatics_profs) %>% 
  kable
#match(presidents, parties)
```

The match function returns a vector of the positions of (first) matches of its first argument in its second. 
 

---

### Sources to acknowledge:

[STAT545 Class notes and excercises by Rashedul Islam](https://github.com/rasiimwe/STAT545_participation/blob/master/cm010/cm010-exercise.md)

[Jenny Bryan's Cheatsheet for dplyr join functions](http://stat545.com/bit001_dplyr-cheatsheet.html)

[Garrick Aden-Buie's tidy verbs](https://github.com/gadenbuie/tidyexplain#readme)
[R-bloggers](https://www.r-bloggers.com/express-intro-to-dplyr/)
